package b58

import (
	"fmt"

	"github.com/mavryk-network/gomav/v2"
	"github.com/mavryk-network/gomav/v2/b58/base58"
	"github.com/mavryk-network/gomav/v2/b58/prefix"
)

// Code generated by generate.go DO NOT EDIT.

func ParseBlockHash(src []byte) (*gomav.BlockHash, error) {
	pre, payload, err := base58.DecodeMV(src)
	if err != nil {
		return nil, err
	}
	if pre != &prefix.BlockHash {
		return nil, fmt.Errorf("gomav: invalid BlockHash encoding")
	}
	var out gomav.BlockHash
	copy(out[:], payload)
	return &out, nil
}

func ParseOperationsHash(src []byte) (*gomav.OperationsHash, error) {
	pre, payload, err := base58.DecodeMV(src)
	if err != nil {
		return nil, err
	}
	if pre != &prefix.OperationListListHash {
		return nil, fmt.Errorf("gomav: invalid OperationsHash encoding")
	}
	var out gomav.OperationsHash
	copy(out[:], payload)
	return &out, nil
}

func ParseContextHash(src []byte) (*gomav.ContextHash, error) {
	pre, payload, err := base58.DecodeMV(src)
	if err != nil {
		return nil, err
	}
	if pre != &prefix.ContextHash {
		return nil, fmt.Errorf("gomav: invalid ContextHash encoding")
	}
	var out gomav.ContextHash
	copy(out[:], payload)
	return &out, nil
}

func ParseChainID(src []byte) (*gomav.ChainID, error) {
	pre, payload, err := base58.DecodeMV(src)
	if err != nil {
		return nil, err
	}
	if pre != &prefix.ChainID {
		return nil, fmt.Errorf("gomav: invalid ChainID encoding")
	}
	var out gomav.ChainID
	copy(out[:], payload)
	return &out, nil
}

func ParseBlockPayloadHash(src []byte) (*gomav.BlockPayloadHash, error) {
	pre, payload, err := base58.DecodeMV(src)
	if err != nil {
		return nil, err
	}
	if pre != &prefix.ValueHash {
		return nil, fmt.Errorf("gomav: invalid BlockPayloadHash encoding")
	}
	var out gomav.BlockPayloadHash
	copy(out[:], payload)
	return &out, nil
}

func ParseCycleNonceHash(src []byte) (*gomav.CycleNonceHash, error) {
	pre, payload, err := base58.DecodeMV(src)
	if err != nil {
		return nil, err
	}
	if pre != &prefix.CycleNonce {
		return nil, fmt.Errorf("gomav: invalid CycleNonceHash encoding")
	}
	var out gomav.CycleNonceHash
	copy(out[:], payload)
	return &out, nil
}

func ParseEd25519PublicKeyHash(src []byte) (*gomav.Ed25519PublicKeyHash, error) {
	pre, payload, err := base58.DecodeMV(src)
	if err != nil {
		return nil, err
	}
	if pre != &prefix.Ed25519PublicKeyHash {
		return nil, fmt.Errorf("gomav: invalid Ed25519PublicKeyHash encoding")
	}
	var out gomav.Ed25519PublicKeyHash
	copy(out[:], payload)
	return &out, nil
}

func ParseSecp256k1PublicKeyHash(src []byte) (*gomav.Secp256k1PublicKeyHash, error) {
	pre, payload, err := base58.DecodeMV(src)
	if err != nil {
		return nil, err
	}
	if pre != &prefix.Secp256k1PublicKeyHash {
		return nil, fmt.Errorf("gomav: invalid Secp256k1PublicKeyHash encoding")
	}
	var out gomav.Secp256k1PublicKeyHash
	copy(out[:], payload)
	return &out, nil
}

func ParseP256PublicKeyHash(src []byte) (*gomav.P256PublicKeyHash, error) {
	pre, payload, err := base58.DecodeMV(src)
	if err != nil {
		return nil, err
	}
	if pre != &prefix.P256PublicKeyHash {
		return nil, fmt.Errorf("gomav: invalid P256PublicKeyHash encoding")
	}
	var out gomav.P256PublicKeyHash
	copy(out[:], payload)
	return &out, nil
}

func ParseBLSPublicKeyHash(src []byte) (*gomav.BLSPublicKeyHash, error) {
	pre, payload, err := base58.DecodeMV(src)
	if err != nil {
		return nil, err
	}
	if pre != &prefix.BLS12_381PublicKeyHash {
		return nil, fmt.Errorf("gomav: invalid BLSPublicKeyHash encoding")
	}
	var out gomav.BLSPublicKeyHash
	copy(out[:], payload)
	return &out, nil
}

func ParseProtocolHash(src []byte) (*gomav.ProtocolHash, error) {
	pre, payload, err := base58.DecodeMV(src)
	if err != nil {
		return nil, err
	}
	if pre != &prefix.ProtocolHash {
		return nil, fmt.Errorf("gomav: invalid ProtocolHash encoding")
	}
	var out gomav.ProtocolHash
	copy(out[:], payload)
	return &out, nil
}

func ParseContractHash(src []byte) (*gomav.ContractHash, error) {
	pre, payload, err := base58.DecodeMV(src)
	if err != nil {
		return nil, err
	}
	if pre != &prefix.ContractHash {
		return nil, fmt.Errorf("gomav: invalid ContractHash encoding")
	}
	var out gomav.ContractHash
	copy(out[:], payload)
	return &out, nil
}

